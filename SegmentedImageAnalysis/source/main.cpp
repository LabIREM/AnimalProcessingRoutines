/* */

/** Includes**/

// STD
#include <iostream>
#include <string>
#include <vector>
#define _USE_MATH_DEFINES
#include <math.h>

// Boost
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>

// ITK
#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkPermuteAxesImageFilter.h"

#include "itkBinaryErodeImageFilter.h"
#include "itkBinaryBallStructuringElement.h"
#include "itkMaskImageFilter.h"
#include "itkDiscreteGaussianImageFilter.h"

#include "itkLabelMap.h"
#include "itkAttributeLabelObject.h"
#include "itkConnectedComponentImageFilter.h"
#include "itkLabelGeometryImageFilter.h"
#include "itkLabelImageToShapeLabelMapFilter.h"
#include "itkLabelStatisticsImageFilter.h"

// Matlab
#include "mat.h"

// Custom
#include "Utility.h"
#include "Matfile.h"
#include "Vertex.h"
#include "Junction.h"
#include "Cell.h"



/** Export data into MAT-file
 *
 * Prepare and export cell, junction, and vertices into a mat-file, respecting the format
 * generated by SIA (matlab) from Boris Guirao.
 *
 **/
//void WriteMatBackup(std::map<unsigned long, Cell> & _cellList, std::map<unsigned long, Junction> & _junctionList, std::map<unsigned long, Vertex> & _vertexList, std::vector<std::string> & _channelList, std::string outputName, unsigned int * _nbCategories)
void WriteMatBackup(std::map<unsigned long, Cell> & _cellList, std::map<unsigned long, Junction> & _junctionList, std::map<unsigned long, Vertex> & _vertexList, std::vector<std::string> & _channelList, std::string outputName)
{
    typedef std::map< unsigned long, Cell> CellMapType;
    typedef std::map< unsigned long, Junction> JunctionMapType;
    typedef std::map< unsigned long, Vertex> VertexMapType;
    typedef std::vector< Cell> CellVectorType;
    typedef std::vector< Junction> JunctionVectorType;
    typedef std::vector< Vertex> VerteVectorType;
    
    CellVectorType CellVectorList;
    MapToVec<CellMapType, CellVectorType>(_cellList, CellVectorList);
    JunctionVectorType JunctionVectorList;
    MapToVec<JunctionMapType, JunctionVectorType>(_junctionList, JunctionVectorList);
    VerteVectorType VectexVectorList;
    MapToVec<VertexMapType, VerteVectorType>(_vertexList, VectexVectorList);
    
    boost::filesystem::path outputPath(outputName);
    boost::filesystem::path folder = outputPath.parent_path();
    if (!boost::filesystem::exists(folder))
    {
        boost::filesystem::create_directory(folder);
    }
    
    MATFile * pmat = matOpen(outputName.c_str(), "w");
    
    mwSize dims[1];
    dims[0] = 1;
    
    std::vector< std::string > cellFieldNames;
    cellFieldNames.push_back("Numbers");
    cellFieldNames.push_back("CategoryTags");
    cellFieldNames.push_back("Indices");
    cellFieldNames.push_back("Areas");
    cellFieldNames.push_back("Perimeters");
    cellFieldNames.push_back("Anisotropies");
    cellFieldNames.push_back("Orientations");
    cellFieldNames.push_back("XYs");
    cellFieldNames.push_back("Vertices");
    cellFieldNames.push_back("nVertices");
    cellFieldNames.push_back("Neighbors");
    cellFieldNames.push_back("nNeighbors");
    cellFieldNames.push_back("ContourIndices");
    cellFieldNames.push_back("DilatedContourIndices");
    cellFieldNames.push_back("ContourChordLengths");
    cellFieldNames.push_back("Sides");
    cellFieldNames.push_back("nSides");
    cellFieldNames.push_back("ChordDisorders");
    cellFieldNames.push_back("Ms");
    cellFieldNames.push_back("nLinks");
    cellFieldNames.push_back("Is");
    cellFieldNames.push_back("Ianisotropies");
    cellFieldNames.push_back("Iorientations");
    cellFieldNames.push_back("Vs");
    cellFieldNames.push_back("Vpolarities");
    cellFieldNames.push_back("Vorientations");
    for (int i = 0; i < _channelList.size(); i++)
    {
        cellFieldNames.push_back("SideIntensityDisorders" + _channelList[i]);
        cellFieldNames.push_back("BGintensities" + _channelList[i]);
        cellFieldNames.push_back("PolarityModes" + _channelList[i]);
    }
    //cellFieldNames.push_back("CATEGORIES");
    
    std::vector< std::string > sideFieldNames;
    sideFieldNames.push_back("Numbers");
    sideFieldNames.push_back("Cells");
    sideFieldNames.push_back("Vertices");
    sideFieldNames.push_back("VertexIndices");
    sideFieldNames.push_back("ChordLengths");
    sideFieldNames.push_back("Indices");
    sideFieldNames.push_back("DilatedIndices");
    //sideFieldNames.push_back("Parts");
    for (int i = 0; i < _channelList.size(); i++)
    {
        sideFieldNames.push_back("Intensities" + _channelList[i]);
        sideFieldNames.push_back("BGintensities" + _channelList[i]);
    }
    
    std::vector< std::string > verticesFieldNames;
    verticesFieldNames.push_back("Numbers");
    verticesFieldNames.push_back("Indices");
    verticesFieldNames.push_back("Cells");
    verticesFieldNames.push_back("nCells");
    verticesFieldNames.push_back("XYs");

    //std::vector< std::string > categoriesFieldNames;
    //categoriesFieldNames.push_back("borderRNs");
    //categoriesFieldNames.push_back("FLRNs");
    //categoriesFieldNames.push_back("coreRNs");
    //categoriesFieldNames.push_back("nonBorderRNs");
    
    std::vector<const char*>  cellFieldNames_c;
    std::transform(cellFieldNames.begin(), cellFieldNames.end(), std::back_inserter(cellFieldNames_c), Convert);
    std::vector<const char*>  sideFieldNames_c;
    std::transform(sideFieldNames.begin(), sideFieldNames.end(), std::back_inserter(sideFieldNames_c), Convert);
    std::vector<const char*>  verticesFieldNames_c;
    std::transform(verticesFieldNames.begin(), verticesFieldNames.end(), std::back_inserter(verticesFieldNames_c), Convert);
    //std::vector<const char*>  categoriesFieldNames_c;
    //std::transform(categoriesFieldNames.begin(), categoriesFieldNames.end(), std::back_inserter(categoriesFieldNames_c), Convert);
    
    mxArray * pcell = mxCreateStructArray(1, dims, cellFieldNames.size(), cellFieldNames_c.data());
    mxArray * pside = mxCreateStructArray(1, dims, sideFieldNames.size(), sideFieldNames_c.data());
    mxArray * pvertices = mxCreateStructArray(1, dims, verticesFieldNames.size(), verticesFieldNames_c.data());
    //mxArray * pcategories = mxCreateStructArray(1, dims, categoriesFieldNames.size(), categoriesFieldNames_c.data());

    FillCellsStructMat(pcell, cellFieldNames, CellVectorList, _channelList.size());
    FillSidesStructMat(pside, sideFieldNames, JunctionVectorList, _channelList.size());
    FillVerticesStructMat(pvertices, verticesFieldNames, VectexVectorList);
    //FillCategoriesStructMat(pcategories, categoriesFieldNames, CellVectorList, _nbCategories);
    
    //int name_field = mxGetFieldNumber(pcell, cellFieldNames_c.back());
    //mxSetFieldByNumber(pcell, 0, name_field, mxDuplicateArray(pcategories)); 

    matPutVariable(pmat, "CELLS", pcell);
    matPutVariable(pmat, "SIDES", pside);
    matPutVariable(pmat, "VERTICES", pvertices);
    
    mxDestroyArray(pside);
    mxDestroyArray(pcell);
    mxDestroyArray(pvertices);
}



/** Walk on skeleton pixels
 *
 * Iterate on the skeleton segmentation and list vertices, junctions, cells
 *
 **/
void SkeletonPixelList(itk::Image<unsigned long, 2>::Pointer image, std::map<unsigned long, Cell> & _cellList, std::map<unsigned long, Junction> & _junctionList, std::map<unsigned long, Vertex> & _vertexList, int radius)
{
    typedef itk::Image<unsigned long, 2> ImageType;
    typedef itk::NeighborhoodIterator              < ImageType > NeighborhoodIteratorType;
    typedef itk::ImageRegionConstIteratorWithIndex < ImageType > ConstIteratorWithIndexType;
    
    
    std::map<unsigned long, Cell>::iterator cIt;
    std::map<unsigned long, Junction>::iterator jIt;
    std::map<unsigned long, Vertex>::iterator vIt;
    
    /** Load and read skeleton pixel list for vertex and neighbours detection **/
    ConstIteratorWithIndexType it(image, image->GetLargestPossibleRegion());
    NeighborhoodIteratorType::RadiusType neigborhoodRadius;
    neigborhoodRadius.Fill(1);
    
    NeighborhoodIteratorType itNeighborhood(neigborhoodRadius, image, image->GetLargestPossibleRegion());
    NeighborhoodIteratorType::OffsetType offset1 = { { -1, -1 } };
    NeighborhoodIteratorType::OffsetType offset2 = { { -1, 0 } };
    NeighborhoodIteratorType::OffsetType offset3 = { { -1, 1 } };
    NeighborhoodIteratorType::OffsetType offset4 = { { 0, -1 } };
    NeighborhoodIteratorType::OffsetType offset5 = { { 0, 1 } };
    NeighborhoodIteratorType::OffsetType offset6 = { { 1, -1 } };
    NeighborhoodIteratorType::OffsetType offset7 = { { 1, 0 } };
    NeighborhoodIteratorType::OffsetType offset8 = { { 1, 1 } };
    
    int width  = image->GetLargestPossibleRegion().GetSize()[0];
    int height = image->GetLargestPossibleRegion().GetSize()[1];
    
    for (it.GoToBegin(), itNeighborhood.GoToBegin(); !it.IsAtEnd(); ++it, ++itNeighborhood)
    {
        unsigned long a(0), b(0), c(0), d(0);
        bool vertexFlag = false;
        if (it.Get() == 0) // only process skeleton pixels (skel pixel = 0)
        {
            if (itNeighborhood.GetPixel(offset1) != 0) // check offset1
            {
                a = itNeighborhood.GetPixel(offset1);
            }
            if (itNeighborhood.GetPixel(offset2) != 0) // check offset2
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset2);
                }
                else if (itNeighborhood.GetPixel(offset2) != a)
                {
                    b = itNeighborhood.GetPixel(offset2);
                }
            }
            if (itNeighborhood.GetPixel(offset3) != 0) // check offset3
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset3);
                }
                else if (itNeighborhood.GetPixel(offset3) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset3);
                    }
                    else if (itNeighborhood.GetPixel(offset3) != b)
                    {
                        c = itNeighborhood.GetPixel(offset3);
                    }
                }
            }
            if (itNeighborhood.GetPixel(offset4) != 0) // check offset4
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset4);
                }
                else if (itNeighborhood.GetPixel(offset4) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset4);
                    }
                    else if (itNeighborhood.GetPixel(offset4) != b)
                    {
                        if (c == 0)
                        {
                            c = itNeighborhood.GetPixel(offset4);
                        }
                        else if (itNeighborhood.GetPixel(offset4) != c)
                        {
                            d = itNeighborhood.GetPixel(offset4);
                        }
                    }
                }
            }
            if (itNeighborhood.GetPixel(offset5) != 0 && d == 0) //check offset5
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset5);
                }
                else if (itNeighborhood.GetPixel(offset5) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset5);
                    }
                    else if (itNeighborhood.GetPixel(offset5) != b)
                    {
                        if (c == 0)
                        {
                            c = itNeighborhood.GetPixel(offset5);
                        }
                        else if (itNeighborhood.GetPixel(offset5) != c)
                        {
                            d = itNeighborhood.GetPixel(offset5);
                        }
                    }
                }
            }
            if (itNeighborhood.GetPixel(offset6) != 0 && d == 0) //check offset6
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset6);
                }
                else if (itNeighborhood.GetPixel(offset6) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset6);
                    }
                    else if (itNeighborhood.GetPixel(offset6) != b)
                    {
                        if (c == 0)
                        {
                            c = itNeighborhood.GetPixel(offset6);
                        }
                        else if (itNeighborhood.GetPixel(offset6) != c)
                        {
                            d = itNeighborhood.GetPixel(offset6);
                        }
                    }
                }
            }
            if (itNeighborhood.GetPixel(offset7) != 0 && d == 0) //check offset7
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset7);
                }
                else if (itNeighborhood.GetPixel(offset7) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset7);
                    }
                    else if (itNeighborhood.GetPixel(offset7) != b)
                    {
                        if (c == 0)
                        {
                            c = itNeighborhood.GetPixel(offset7);
                        }
                        else if (itNeighborhood.GetPixel(offset7) != c)
                        {
                            d = itNeighborhood.GetPixel(offset7);
                        }
                    }
                }
            }
            if (itNeighborhood.GetPixel(offset8) != 0 && d == 0) //check offset8
            {
                if (a == 0)
                {
                    a = itNeighborhood.GetPixel(offset8);
                }
                else if (itNeighborhood.GetPixel(offset8) != a)
                {
                    if (b == 0)
                    {
                        b = itNeighborhood.GetPixel(offset8);
                    }
                    else if (itNeighborhood.GetPixel(offset8) != b)
                    {
                        if (c == 0)
                        {
                            c = itNeighborhood.GetPixel(offset8);
                        }
                        else if (itNeighborhood.GetPixel(offset8) != c)
                        {
                            d = itNeighborhood.GetPixel(offset8);
                        }
                    }
                }
            }
            if (b != 0) // to prevent 1-neighbour cases (a.k.a. bad skeletonization case)
            {
                // dilate the current pixel for border dilatation computation
                itk::Index < 2 > currentIndex = it.GetIndex();
                std::vector < itk::Index < 2 > > smallDilNei;
                for (int i = -radius; i <= radius; i++)
                {
                    for (int j = -radius; j <= radius; j++)
                    {
                        if ((currentIndex[0] + i >= 0) && (currentIndex[0] + i < width) &&
                            (currentIndex[1] + j >= 0) && (currentIndex[1] + j < height))
                        {
                            itk::Index < 2 > t = { { currentIndex[0] + i, currentIndex[1] + j } };
                            smallDilNei.push_back(t);
                        }
                    }
                }
                
                unsigned long tmpVertexLabel = sub2ind(width, height, currentIndex);
                if (c == 0) // dual case
                {
                    // border image vertex verification
                    if ((currentIndex[0] == 0 || currentIndex[1] == 0 ||
                         currentIndex[0] == width - 1 || currentIndex[1] == height - 1))
                    {
                        vertexFlag = true;
                        
                        // we manage the vertices structure
                        vIt = _vertexList.find(tmpVertexLabel);
                        if (vIt == _vertexList.end())
                        {
                            Vertex tmpVertex(tmpVertexLabel);
                            tmpVertex.SetCoordinate(currentIndex[0], currentIndex[1]);
                            tmpVertex.SetLinearIndex(tmpVertexLabel);
                            tmpVertex.AddCell(a);
                            tmpVertex.AddCell(b);
                            _vertexList.insert(std::make_pair(tmpVertexLabel, tmpVertex));
                        }
                    }
                    
                    // we manage the junction list structure
                    unsigned long tmpJunctionLabel = CantorPairing(a, b);
                    jIt = _junctionList.find(tmpJunctionLabel);
                    if (jIt != _junctionList.end()) // Junction already existing, we complete it
                    {
                        jIt->second.AddPixel(currentIndex);
                        if (vertexFlag)
                        {
                            jIt->second.AddVertex(tmpVertexLabel);
                        }
                        for (int j = 0; j < smallDilNei.size(); j++)
                        {
                            jIt->second.AddSmallDilPixel(smallDilNei[j]);
                        }
                    }
                    else // First time we see this junction, we create it and add it to the list
                    {
                        Junction tmpJunction(tmpJunctionLabel);
                        tmpJunction.AddCell(a);
                        tmpJunction.AddCell(b);
                        tmpJunction.AddPixel(currentIndex);
                        if (vertexFlag)
                        {
                            tmpJunction.AddVertex(tmpVertexLabel);
                        }
                        for (int j = 0; j < smallDilNei.size(); j++)
                        {
                            tmpJunction.AddSmallDilPixel(smallDilNei[j]);
                        }
                        _junctionList.insert(std::make_pair(tmpJunctionLabel, tmpJunction));
                    }
                    
                    // we manage the cell list structure
                    cIt = _cellList.find(a);                                  // get cell a
                    cIt->second.AddNeighbor(b);                               // a is a neighbour of b
                    cIt->second.AddJunction(tmpJunctionLabel);                // junction (ab) is link to a
                    if (vertexFlag)
                    {
                        cIt->second.AddVertex(tmpVertexLabel);                // add pixel as vertex
                        cIt->second.SetCategory(Cell::CATEGORY::BORDERCELL);  // set bordercell category
                    }
                    cIt = _cellList.find(b);                                     // get cell b
                    cIt->second.AddNeighbor(a);                               // b is a neighbour of a
                    cIt->second.AddJunction(tmpJunctionLabel);                // junction (ab) is link to b
                    if (vertexFlag)
                    {
                        cIt->second.AddVertex(tmpVertexLabel);                // add pixel as vertex
                        cIt->second.SetCategory(Cell::CATEGORY::BORDERCELL);  // set bordercell category
                    }
                }
                else if (d == 0) // triple case
                {
                    // we manage the vertices structure
                    vIt = _vertexList.find(tmpVertexLabel);
                    if (vIt == _vertexList.end())
                    {
                        Vertex tmpVertex(tmpVertexLabel);                          // create the vertex
                        tmpVertex.SetCoordinate(currentIndex[0], currentIndex[1]); // add coordinate xy
                        tmpVertex.SetLinearIndex(tmpVertexLabel);                  // add linear index (= to label)
                        tmpVertex.AddCell(a);                                      // add cell a
                        tmpVertex.AddCell(b);                                      // add cell b
                        tmpVertex.AddCell(c);                                      // add cell c
                        _vertexList.insert(std::make_pair(tmpVertexLabel, tmpVertex));
                    }
                    else
                    {
                        std::cerr << "triple case - vertex already in the list ... huston, problem ..." << std::endl;
                    }
                    
                    // we manage the junction list structure
                    unsigned long tmpCellsLabels[3] = { a, b, c };
                    unsigned long tmpJunctionLabels[3];
                    tmpJunctionLabels[0] = CantorPairing(b, c);
                    tmpJunctionLabels[1] = CantorPairing(c, a);
                    tmpJunctionLabels[2] = CantorPairing(a, b);
                    
                    for (int i = 0; i < 3; i++)
                    {
                        jIt = _junctionList.find(tmpJunctionLabels[i]);
                        if (jIt != _junctionList.end())
                        {
                            jIt->second.AddPixel(currentIndex);               // add pixel to junction
                            jIt->second.AddVertex(tmpVertexLabel);            // add vertex to junction
                            for (int j = 0; j < smallDilNei.size(); j++)
                            {
                                jIt->second.AddSmallDilPixel(smallDilNei[j]); // add dilated pixel indices
                            }
                        }
                        else
                        {
                            Junction tmpJunction(tmpJunctionLabels[i]);       // create junction bc
                            tmpJunction.AddCell(tmpCellsLabels[(i + 1) % 3]); // add cell b
                            tmpJunction.AddCell(tmpCellsLabels[(i + 2) % 3]); // add cell c
                            tmpJunction.AddPixel(currentIndex);               // add pixel to junction
                            tmpJunction.AddVertex(tmpVertexLabel);            // add vertex to junction
                            for (int j = 0; j < smallDilNei.size(); j++)
                            {
                                tmpJunction.AddSmallDilPixel(smallDilNei[j]); // add dilated pixel indices
                            }
                            _junctionList.insert(std::make_pair(tmpJunctionLabels[i], tmpJunction));
                        }
                    }
                    
                    // we manage the cell list structure
                    for (int i = 0; i < 3; i++)
                    {
                        cIt = _cellList.find(tmpCellsLabels[i]);                 // get cell a
                        cIt->second.AddNeighbor(tmpCellsLabels[(i + 1) % 3]);    // b is a neighbour of a
                        cIt->second.AddNeighbor(tmpCellsLabels[(i + 2) % 3]);    // c is a neighbour of a
                        cIt->second.AddJunction(tmpJunctionLabels[(i + 1) % 3]); // add junction ca
                        cIt->second.AddJunction(tmpJunctionLabels[(i + 2) % 3]); // add junction ab
                        cIt->second.AddVertex(tmpVertexLabel);                   // add pixel as vertex
                    }
                }
                else // quad case
                {
                    // we manage the vertices structure
                    vIt = _vertexList.find(tmpVertexLabel);
                    if (vIt == _vertexList.end())
                    {
                        Vertex tmpVertex(tmpVertexLabel);                          // create the vertex
                        tmpVertex.SetCoordinate(currentIndex[0], currentIndex[1]); // add coordinate xy
                        tmpVertex.SetLinearIndex(tmpVertexLabel);                  // add linear index (= to label)
                        tmpVertex.AddCell(a);                                      // add cell a
                        tmpVertex.AddCell(b);                                      // add cell b
                        tmpVertex.AddCell(c);                                      // add cell c
                        tmpVertex.AddCell(d);                                      // add cell d
                        _vertexList.insert(std::make_pair(tmpVertexLabel, tmpVertex));
                    }
                    
                    // we manage the junction list structure
                    unsigned long tmpCellsLabels[4] = { a, b, c, d };
                    for (int i = 0; i <4; i++)
                    {
                        for (int j = i + 1; j < 4; j++)
                        {
                            unsigned long jTmp = CantorPairing(tmpCellsLabels[i], tmpCellsLabels[j]);
                            jIt = _junctionList.find(jTmp);
                            if (jIt != _junctionList.end())
                            {
                                jIt->second.AddPixel(currentIndex);               // add pixel to junction
                                jIt->second.AddVertex(tmpVertexLabel);            // add vertex to junction
                                for (int j = 0; j < smallDilNei.size(); j++)
                                {
                                    jIt->second.AddSmallDilPixel(smallDilNei[j]);
                                }
                            }
                            else
                            {
                                Junction tmpJunction(jTmp);                       // create junction bc
                                tmpJunction.AddCell(tmpCellsLabels[i]);           // add cell b
                                tmpJunction.AddCell(tmpCellsLabels[j]);           // add cell c
                                tmpJunction.AddPixel(currentIndex);               // add pixel to junction
                                tmpJunction.AddVertex(tmpVertexLabel);            // add vertex to junction
                                for (int j = 0; j < smallDilNei.size(); j++)
                                {
                                    tmpJunction.AddSmallDilPixel(smallDilNei[j]);
                                }
                                _junctionList.insert(std::make_pair(jTmp, tmpJunction));
                            }
                        }
                    }
                    
                    // we manage the cell list structure
                    for (int i = 0; i < 4; i++)
                    {
                        unsigned long cpl1, cpl2, cpl3;
                        cpl1 = CantorPairing(tmpCellsLabels[i % 4], tmpCellsLabels[(i + 1) % 4]);
                        cpl2 = CantorPairing(tmpCellsLabels[i % 4], tmpCellsLabels[(i + 2) % 4]);
                        cpl3 = CantorPairing(tmpCellsLabels[i % 4], tmpCellsLabels[(i + 3) % 4]);
                        cIt = _cellList.find(tmpCellsLabels[i]);                    // get cell a
                        cIt->second.AddNeighbor(tmpCellsLabels[(i + 1) % 4]);    // b is a neighbour of a
                        cIt->second.AddNeighbor(tmpCellsLabels[(i + 2) % 4]);    // c is a neighbour of a
                        cIt->second.AddNeighbor(tmpCellsLabels[(i + 3) % 4]);    // d is a neighbour of a
                        cIt->second.AddJunction(cpl1);                           // add junction ab
                        cIt->second.AddJunction(cpl2);                           // add junction ac
                        cIt->second.AddJunction(cpl3);                           // add junction ad
                        cIt->second.AddVertex(tmpVertexLabel);                   // add pixel as vertex
                    }
                }
            }
        }
        else
        {
            // This is a label pixel, not a skeleton pixel.
            // For now we do nothing, but we will probably use this space to extract cell category information
            // e.g. is the cell a border cell, a first layer cell, etc.
        }
    } // end iteration on each pixel of labeled image
}










int main(int argc, char ** argv)
{
    
    /** Benchmarking **/
    clock_t tStart, t1, t2;
    tStart = clock();
    t1 = tStart;
    t2 = tStart;
    
    /** other parameters **/
    itk::FixedArray<unsigned int, 2> order;
    order[0] = 1;
    order[1] = 0;
    
    int dilRadius = 1;
    float blurVariance = 25;
    
    
    /** Commande line parameters **/
    std::string binaryImageName, outputPathMatfile;
    std::string channelImageName, channelName;
    std::string channelImageName2, channelName2;
    std::string channelImageName3, channelName3;
    float scale1D;
    
    
    /** Commande line definition and default values **/
    boost::program_options::options_description desc("Allowed options");
    desc.add_options()
    ("help", "produce help message")
    ("binary", boost::program_options::value<std::string>(&binaryImageName), "Binary image (segmentation)")
    ("channel", boost::program_options::value<std::string>(&channelImageName), "First channel image path")
    ("name", boost::program_options::value<std::string>(&channelName)->default_value("Cad"), "First channel name")
    ("scale", boost::program_options::value<float>(&scale1D)->default_value(1.0), "1 Dimension pixel scale (um)")
    ("output", boost::program_options::value<std::string>(&outputPathMatfile), "Output mat-file path")
    // Optional: additional channels
    ("channel2", boost::program_options::value<std::string>(&channelImageName2)->default_value(""), "Second channel image path")
    ("channel3", boost::program_options::value<std::string>(&channelImageName3)->default_value(""), "Third channel image path")
    ("name2", boost::program_options::value<std::string>(&channelName2)->default_value(""), "Second channel name")
    ("name3", boost::program_options::value<std::string>(&channelName3)->default_value(""), "Third channel name")
    ;
    
    boost::program_options::variables_map vm;
    boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), vm);
    boost::program_options::notify(vm);
    
    if (vm.count("help"))
    {
        std::cout << "Compiled : " << __DATE__ << " at " << __TIME__ << std::endl;
        std::cout << desc << "\n";
        return EXIT_SUCCESS;
    }
    
    
    /** Channel names and images path **/
    std::vector< std::string > channelImagePathList;
    std::vector< std::string > channelImageNameList;
    channelImagePathList.push_back(channelImageName);
    channelImageNameList.push_back(channelName);
    if (!channelImageName2.empty())
    {
        channelImagePathList.push_back(channelImageName2);
        channelImageNameList.push_back(channelName2);
        if (!channelImageName3.empty())
        {
            channelImagePathList.push_back(channelImageName3);
            channelImageNameList.push_back(channelName3);
        }
    }
    
    
    
    
    /** Typedef **/
    
    const unsigned int     Dimension = 2;
    typedef double         PixelType;
    typedef unsigned char  UInt8Type;
    typedef unsigned long  LabelType;
    
    
    typedef itk::Image < PixelType, Dimension > ImageType;
    typedef itk::Image < UInt8Type, Dimension > UInt8ImageType;
    typedef itk::Image < LabelType, Dimension > LabelImageType;
    
    typedef itk::ImageFileReader < UInt8ImageType > BinaryImageReaderType;
    typedef itk::ImageFileReader < ImageType > ImageReaderType;
    
    typedef itk::PermuteAxesImageFilter < ImageType > ImageTransposeFilterType;
    typedef itk::PermuteAxesImageFilter < UInt8ImageType > BinrayImageTransposeFilterType;
    
    typedef itk::BinaryBallStructuringElement < UInt8Type, Dimension > StrElementType;
    typedef itk::BinaryErodeImageFilter < UInt8ImageType, UInt8ImageType, StrElementType > BinaryErodeImageFilterType;
    typedef itk::MaskImageFilter < ImageType, UInt8ImageType > MaskFilterType;
    typedef itk::DiscreteGaussianImageFilter < ImageType, ImageType > GaussianFilterType;
    
    typedef itk::ShapeLabelObject < LabelType, Dimension > ShapeLabelObjectType;
    typedef itk::LabelMap < ShapeLabelObjectType > ShapeLabelMapType;
    
    typedef itk::ConnectedComponentImageFilter < UInt8ImageType, LabelImageType > ConnectedComponentImageFilterType;
    typedef itk::LabelStatisticsImageFilter < ImageType, LabelImageType > LabelStatisticImageFilterType;
    typedef itk::LabelImageToShapeLabelMapFilter < LabelImageType > LabelImageToShapeLabelMapFilterType;
    typedef itk::LabelGeometryImageFilter < LabelImageType, ImageType > LabelGeometryImageFilterType;
    
    
    /** Input **/
    
    /** Binary Image **/
    BinaryImageReaderType::Pointer binaryReader = BinaryImageReaderType::New();
    binaryReader->SetFileName(binaryImageName);
    BinrayImageTransposeFilterType::Pointer binaryTransposeFilter = BinrayImageTransposeFilterType::New();
    binaryTransposeFilter->SetInput(binaryReader->GetOutput());
    binaryTransposeFilter->SetOrder(order);
    try
    {
        binaryTransposeFilter->Update();
    }
    catch (itk::ExceptionObject & excp)
    {
        std::cerr << "Error ... binaryTransposeFilter->Update(); " << std::endl;
        std::cerr << excp << std::endl;
    }
    UInt8ImageType::Pointer binaryImage = binaryTransposeFilter->GetOutput();
    binaryImage->DisconnectPipeline();
    
    /** Channel Images **/
    std::vector< ImageType::Pointer > channelImages;
    
    ImageReaderType::Pointer channelReader = ImageReaderType::New();
    ImageTransposeFilterType::Pointer channelTransposeFilter = ImageTransposeFilterType::New();
    channelTransposeFilter->SetInput(channelReader->GetOutput());
    channelTransposeFilter->SetOrder(order);
    for (unsigned int i = 0; i < channelImagePathList.size(); i++)
    {
        channelReader->SetFileName(channelImagePathList[i]);
        try
        {
            channelTransposeFilter->Update();
        }
        catch (itk::ExceptionObject & excp)
        {
            std::cerr << "Error ... channelTransposeFilter->Update(); " << std::endl;
            std::cerr << excp << std::endl;
        }
        ImageType::Pointer tmpImage = channelTransposeFilter->GetOutput();
        tmpImage->DisconnectPipeline();
        channelImages.push_back(tmpImage);
    }
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Read input images" << std::endl;
    
    
    /** Background Images **/
    std::vector< ImageType::Pointer > backgroundImages;
    
    StrElementType structuringElement;
    structuringElement.SetRadius(dilRadius);
    structuringElement.CreateStructuringElement();
    BinaryErodeImageFilterType::Pointer erodeFilter = BinaryErodeImageFilterType::New();
    erodeFilter->SetInput(binaryImage);
    erodeFilter->SetKernel(structuringElement);
    MaskFilterType::Pointer maskFilter = MaskFilterType::New();
    maskFilter->SetMaskImage(erodeFilter->GetOutput());
    GaussianFilterType::Pointer gaussianFilter = GaussianFilterType::New();
    gaussianFilter->SetInput(maskFilter->GetOutput());
    gaussianFilter->SetVariance(blurVariance);
    for (unsigned int i = 0; i < channelImages.size(); i++)
    {
        maskFilter->SetInput(channelImages[i]);
        try
        {
            gaussianFilter->Update();
        }
        catch (itk::ExceptionObject & excp)
        {
            std::cerr << "Error ... gaussianFilter->Update(); " << std::endl;
            std::cerr << excp << std::endl;
        }
        ImageType::Pointer tmpImage = gaussianFilter->GetOutput();
        tmpImage->DisconnectPipeline();
        backgroundImages.push_back(tmpImage);
    }
    
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Estimate background image" << std::endl;
    
    
    
    /** Label map computation **/
    ConnectedComponentImageFilterType::Pointer binaryLabelFilter = ConnectedComponentImageFilterType::New();
    binaryLabelFilter->SetInput(binaryImage);
    
    // Geometry Extraction
    LabelGeometryImageFilterType::Pointer geometryFilter = LabelGeometryImageFilterType::New();
    geometryFilter->SetInput(binaryLabelFilter->GetOutput());
    geometryFilter->SetIntensityInput(channelImages[0]);
    geometryFilter->CalculatePixelIndicesOn(); // get pixel index list per cell
    try
    {
        geometryFilter->Update();
    }
    catch (itk::ExceptionObject & excp)
    {
        std::cerr << "Error ... geometryFilter->Update(); " << std::endl;
        std::cerr << excp << std::endl;
    }
    
    // Shape Extraction
    LabelImageToShapeLabelMapFilterType::Pointer shapeFilter = LabelImageToShapeLabelMapFilterType::New();
    shapeFilter->SetInput(binaryLabelFilter->GetOutput());
    try
    {
        shapeFilter->Update();
    }
    catch (itk::ExceptionObject & excp)
    {
        std::cerr << "Error ... shapeFilter->Update(); " << std::endl;
        std::cerr << excp << std::endl;
    }
    
    // Statistic Extraction
    LabelStatisticImageFilterType::Pointer statisticFilter = LabelStatisticImageFilterType::New();
    statisticFilter->SetInput(channelImages[0]);
    statisticFilter->SetLabelInput(binaryLabelFilter->GetOutput());
    try
    {
        statisticFilter->Update();
    }
    catch (itk::ExceptionObject & excp)
    {
        std::cerr << "Error ... statisticFilter->Update(); " << std::endl;
        std::cerr << excp << std::endl;
    }
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Compute region features" << std::endl;
    
    unsigned int width = binaryImage->GetLargestPossibleRegion().GetSize()[0];
    unsigned int height = binaryImage->GetLargestPossibleRegion().GetSize()[1];
    
    Cell::WIDTH = width;
    Cell::HEIGHT = height;
    Junction::WIDTH = width;
    Junction::HEIGHT = height;
    
    std::map < unsigned long, Cell > CellList;
    std::map < unsigned long, Junction > JunctionList;
    std::map < unsigned long, Vertex > VerticesList;
    
    std::map < unsigned long, Cell > ::iterator cIt;
    std::map < unsigned long, Junction > ::iterator jIt;
    std::map < unsigned long, Vertex > ::iterator vIt;

    /** Label Geometry Features Extraction **/
    LabelGeometryImageFilterType::LabelsType::iterator geometryIt;
    LabelGeometryImageFilterType::LabelsType allLabels = geometryFilter->GetLabels();
    for (geometryIt = allLabels.begin(); geometryIt != allLabels.end(); geometryIt++)
    {
        LabelGeometryImageFilterType::LabelPixelType labelValue = *geometryIt; // label id
        if (labelValue != 0) // test label 0 correspond to background
        {
            // get geometric features
            float volume = geometryFilter->GetVolume(labelValue);                                 // volume
            float centroidX = geometryFilter->GetCentroid(labelValue)[0];                         // centroid x coordinate
            float centroidY = geometryFilter->GetCentroid(labelValue)[1];                         // centroid y coordinate
            float majorAxisLength = geometryFilter->GetMajorAxisLength(labelValue);               // major axis length
            float minorAxisLength = geometryFilter->GetMinorAxisLength(labelValue);               // minor axis length
            float anisotropy = 1 - (minorAxisLength / majorAxisLength);                           // anisotropy
            float orientation = (geometryFilter->GetOrientation(labelValue) * 180.0 / M_PI) - 90; // orientation (in degree - range [90 -90])
            // float eccentricity = geometryFilter->GetEccentricity(labelValue);                     // eccentricity
            // float elongation = geometryFilter->GetElongation(labelValue);                         // elongation
            
            // get image pixel list and region
            std::vector < itk::Index < 2 > > pixelList = geometryFilter->GetPixelIndices(labelValue);
            
            // scaling
            volume    *= std::pow(scale1D, 2);

            // create a new cell object and set features associated to it
            Cell cell(labelValue, Cell::CATEGORY::CORECELL);
            cell.SetPixelsList(pixelList);
            cell.SetArea(volume);
            cell.SetCentroid(centroidX, centroidY);
            cell.SetAnisotropy(anisotropy);
            cell.SetOrientation(orientation);
            // cell.SetEccentricity(eccentricity);
            // cell.SetElongation(elongation);
            // cell.SetMajorAxisLength(majorAxisLength);
            // cell.SetMinorAxisLength(minorAxisLength);
            CellList.insert(std::make_pair(labelValue, cell));
        }
    }
    
    /** Label Shape Features Extraction **/
    // NB: cannot use iterator because of weird label value causing segfault (?)
    ShapeLabelMapType::Pointer shapeMap = shapeFilter->GetOutput();
    for (unsigned int i = 0; i < shapeMap->GetNumberOfLabelObjects(); i++)
    {
        ShapeLabelMapType::LabelObjectPointerType obj = shapeMap->GetNthLabelObject(i);
        if (obj->GetLabel() != 0)
        {
            float perimeter = obj->GetPerimeter();   // perimeter
            // double roundness = obj->GetRoundness();   // roundness
            // double elongation = obj->GetElongation(); // elongation

            // scaling
            perimeter *= scale1D;
            
            // find cell with corresponding label and add shape features
            cIt = CellList.find(obj->GetLabel());
            cIt->second.SetPerimeter(perimeter);
            // cIt->second.SetRoundness(roundness);
            // cIt->second.SetElongation(elongation);
        }
    }
    
    ///** Label Statistics Features Extraction **/
    //// NB: should we save region? could be usefull for future processing on the cell
    //LabelStatisticImageFilterType::ValidLabelValuesContainerType::const_iterator statisticIt;
    //for (statisticIt = statisticFilter->GetValidLabelValues().begin(); statisticIt != statisticFilter->GetValidLabelValues().end(); statisticIt++)
    //{
    //    if (statisticFilter->HasLabel(*statisticIt))
    //    {
    //        LabelStatisticImageFilterType::LabelPixelType labelValue = *statisticIt; // label id
    //        if (labelValue != 0) // label 0 correspond to background
    //        {
    //            double minimum = statisticFilter->GetMinimum(labelValue);   // cell minimum intensity
    //            double maximum = statisticFilter->GetMaximum(labelValue);   // cell maximum intensity
    //            double average = statisticFilter->GetMean(labelValue);      // cell average intensity
    //            double variance = statisticFilter->GetVariance(labelValue); // cell variance intensity
    //            
    //            // find cell with corresponding label and add statistic features
    //            cIt = CellList.find(labelValue);
    //            cIt->second.SetMinimumIntensity(minimum);
    //            cIt->second.SetMaximumIntensity(maximum);
    //            cIt->second.SetAverageIntensity(average);
    //            cIt->second.SetVarianceIntensity(variance);
    //        }
    //    }
    //}
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Extract region features and build Cell map" << std::endl;
    
    SkeletonPixelList(binaryLabelFilter->GetOutput(), CellList, JunctionList, VerticesList, dilRadius);
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Build junctions and vertices map" << std::endl;
    
    // Compute junctions features
    for (jIt = JunctionList.begin(); jIt != JunctionList.end(); ++jIt)
    {
        jIt->second.SortCellList();
        jIt->second.ComputeChordsLength(VerticesList, scale1D);              // chord length computation
    }
    // Compute cell features
    for (cIt = CellList.begin(); cIt != CellList.end(); ++cIt)
    {
        cIt->second.ComputeCategory(CellList);                               // Cell category computing
        cIt->second.ComputeJunctionsPixelsList(JunctionList);                // Diltated cell computation
        cIt->second.ComputeChords(JunctionList);                             // chord length computation
        cIt->second.ComputeInertia(scale1D, order);                          // Inertia tensor computation
        cIt->second.ComputeTexture(CellList, JunctionList, scale1D, order);  // Texture tensor computation
        cIt->second.ComputeVertices(VerticesList, order);                    // Vertex tensor computation
    }
    // Compute intensity features
    for (int i = 0; i < channelImages.size(); i++)
    {
        for (jIt = JunctionList.begin(); jIt != JunctionList.end(); ++jIt)
        {
            jIt->second.ComputeIntensities(channelImages[i], backgroundImages[i]);
        }
        for (cIt = CellList.begin(); cIt != CellList.end(); ++cIt)
        {
            cIt->second.ComputeIntensities(channelImages[i], backgroundImages[i]);
            cIt->second.ComputePolarityMode(channelImages[i], order, true);
        }
    }

    //unsigned int nbCategories[3] = { 0 };
    for (cIt = CellList.begin(); cIt != CellList.end(); ++cIt)
    {
        float x = (cIt->second.GetCentroid()[0] + 1 ) * scale1D; // +1 because matlab start at 1
        float y = (cIt->second.GetCentroid()[1] + 1 ) * scale1D; // scaling to convert to um
        cIt->second.SetCentroid(x, y);
        //if (cIt->second.GetCategory() == 0)
        //{
        //    nbCategories[0]++;
        //}
        //else if (cIt->second.GetCategory() == 1)
        //{
        //    nbCategories[1]++;
        //}
        //else
        //{
        //    nbCategories[2]++;
        //}
    }
    for (vIt = VerticesList.begin(); vIt != VerticesList.end(); ++vIt)
    {
        float x = (vIt->second.GetCoordinate()[0] + 1) * scale1D; // +1 because matlab start at 1
        float y = (vIt->second.GetCoordinate()[1] + 1) * scale1D; // scaling to convert to um
        vIt->second.SetCoordinate(x, y);
    }

    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Compute junctions and cells extra features" << std::endl;
    
    //WriteMatBackup(CellList, JunctionList, VerticesList, channelImageNameList, outputPathMatfile, nbCategories);
    WriteMatBackup(CellList, JunctionList, VerticesList, channelImageNameList, outputPathMatfile);
    
    /** Benchmarking **/
    t1 = t2;
    t2 = clock();
    std::cout << "Processing time : " << (float)(t2 - t1) / CLOCKS_PER_SEC << " sec - Save data into mat-file" << std::endl;
    
    /** Benchmarking **/
    std::cout << "Total processing time : " << (float)(clock() - tStart) / CLOCKS_PER_SEC << " sec" << std::endl;
    
    /** That's all folks! **/
    return EXIT_SUCCESS;
}
